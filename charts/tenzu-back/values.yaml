# Default values for tenzu-back.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# -- number of pod replicas for the api backend and the worker service if not using autoscaling
replicaCount: 1

# Number of replicas for the reverse proxy deployment
caddy:
  replicas: 1

# gunicorn options
# -- number workers started by gunicorn
workersQuantity: 1
# -- timeout of workers used by gunicorn
workersTimeout: 120
# -- level of log produced by gunicorn
logLevel: "warning"

postgresql:
  # -- To configure the postgresql connexion you can use global or local values.
  # Local values can use an existing secret, direct values or a mix of both
  # Only use on method for each expected value
  auth:
    # -- (string) existing secret where all necessary value can be found
    existingSecret:
    # -- (string) key to access value in existingSecret, used to populate `TENZU_DB__PASSWORD`
    passwordKey:
    # -- (string) key to access value in existingSecret, used to populate `TENZU_DB__NAME`
    databaseKey:
    # -- (string) key to access value in existingSecret, used to populate `TENZU_DB__USER`
    usernameKey:
    # -- (string) password value, used to populate `TENZU_DB__PASSWORD`
    password:
    # -- (string) database name value, used to populate `TENZU_DB__NAME`
    database:
    # -- (string) username value, used to populate `TENZU_DB__USER`
    username:
  # -- (string) Used to populate `TENZU_DB__HOST`
  host:

# Specify redis configuration, password can be given directly or through a secret, it can also be defined as a global
redis:
  # -- Used to populate `TENZU_EVENTS__REDIS_OPTIONS`
  options: '{"health_check_interval": 5}'
  # -- (string) Used to populate `TENZU_EVENTS__REDIS_HOST`
  # could be something like "tenzu-redis-headless.tenzu.svc.cluster.local"
  host:
  # -- (string) Used to populate `TENZU_EVENTS__REDIS_PASSWORD`
  # using the passed value directly
  password:
  # -- (string) Used to populate `TENZU_EVENTS__REDIS_PASSWORD`
  # If you want to use an existing secret for the password instead
  existingSecret:
  # -- (string) Used to populate `TENZU_EVENTS__REDIS_PASSWORD`
  # If you use redis.existingSecret, you must set this key to the corresponding value to use in the secret
  passwordKey:

sentry:
  # -- Whether to set the environment variable expected by the error tracker
  enabled: False
  # -- (string) Used to populate SENTRY_DSN
  dsn:
  # -- (string) Used to populate SENTRY_ENVIRONMENT, SENTRY_RELEASE will be set using the image.tag value
  environment:

# -- Used to populate `TENZU_SECRET_KEY`
secretKey:
# -- Used to populate `TENZU_TOKENS__SIGNING_KEY`
tokenSigningKey:

# -- additionnal environment variable to set on every jobs and on the backend and task queue Deployment objects.
env: []
# -- additionnal environment variable to set on every jobs and on the backend and task queue Deployment objects,
# fecthed from a seceret or config map
envFrom: []

email:
  # -- Used to populate `TENZU_EMAIL__EMAIL_USE_TLS`
  tls: True
  # -- Used to populate `TENZU_EMAIL__EMAIL_USE_SSL`
  ssl: False
  # -- Used to populate `TENZU_EMAIL__EMAIL_PORT`
  port: 547
  # -- (string) Used to populate `TENZU_EMAIL__DEFAULT_FROM_EMAIL`
  defaultFrom:
  # -- (string) Used to populate `TENZU_EMAIL__EMAIL_HOST`
  host:
  # -- (string) Used to populate `TENZU_EMAIL__EMAIL_HOST_USER`
  user:
  # -- (string) Used to populate `TENZU_EMAIL__EMAIL_HOST_PASSWORD`
  password:
  # -- (string) Used to populate `TENZU_SUPPORT_EMAIL`
  supportEmail:

# -- Image to use for the application
image:
  repository: ghcr.io/biru-scop/tenzu-back
  pullPolicy: IfNotPresent
  # -- Overrides the image tag
  # @default -- Uses the .Chart.AppVersion if not set
  tag: latest

# -- List of secrets needed to pull an image from a private repository
# (see: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/)
imagePullSecrets:

# -- Used by name template: to fill the app.kubernetes.io/name label
# @default -- will use .Chart.Name
nameOverride: ""
# -- Used by fullname template: to fill the name of all created kubernetes component
# @default -- will use .Release.Name suffixed with name template, if .Release.Name does not already contains it
fullnameOverride: ""

# -- service account properties
serviceAccount:
  # -- Specifies whether a service account should be created
  create: true
  # -- Automatically mount a ServiceAccount's API credentials
  automount: true
  # -- Annotations to add to the service account
  annotations: {}
  # -- The name of the service account to use.
  # @default -- If create is true, a name is generated using the fullname template, else it will be set to "default"
  name: ""

# -- Extra annotation to put on backend and task queue Deployment objects
podAnnotations: {}
# -- Extra labels to put on backend and task queue Deployment objects
podLabels: {}
# -- definition of the pod level securityContext on backend and task queue Deployment objects
podSecurityContext: {}
# -- definition of the container level securityContext on backend and task queue Deployment objects
securityContext: {}

service:
  # -- service type defined for the backend and the reverse proxy
  type: ClusterIP
  # -- service port to access the backend
  port: 8000

# -- properties used to define an Ingress
ingress:
  enabled: false
  # -- will be used to set ingressClassName and "kubernetes.io/ingress.class" annotation depending on k8s version
  className: ""
  # -- ingress annotations, can be "kubernetes.io/ingress.class", "cert-manager.io/cluster-issuer", etc.
  # @default -- Will set kubernetes.io/ingress.class to ingress.className if needed
  annotations: {}
  # -- list of the hosts that will be exposed to access the reverse proxy service
  hosts: []
  # -- Expect values in format {secretName: "", hosts: []},
  # You must define tls for the host used as backendDomain if it is present in "ingress.hosts"
  # since we expect HTTPS with the way tenzu-back.urls are defined
  tls: []

# -- container's resources definition set on every jobs and on the backend and task queue Deployment objects,
# If you want to set it, use the following format: {limits: {cpu: 100m, memory: 128Mi}, requests: cpu: 100m, memory: 128Mi}}
resources: {}

# -- livenessProbe for the container of the backend service
livenessProbe:
  httpGet:
    path: /api/v1/healthcheck
    port: 8000
# -- readinessProbe for the container of the backend service
readinessProbe: 
  httpGet:
    path: /api/v1/healthcheck
    port: 8000
# -- Whether to define a HorizontalPodAutoscaler with the following scaling properties on cpu and memory consumption
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# -- nodeSelector pod property for the backend and task queue Deployment objects
nodeSelector: {}
# -- tolerations pod property for the backend and task queue Deployment objects
tolerations: []
# -- affinity pod property for the backend and task queue Deployment objects
affinity: {}

# -- list of object in format {name: string, schedule: string, command: string[]}
# schedule and command should be set to the format expected by CronJob (see: https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)
cronJobs: []

# TODO fix all values related to volumes and document explicit usage
persistentVolumeClaim:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      # Change with the size you need
      storage: 10Gi
  # storageClassName: longhorn
# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false
# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

# -- global values to share properties among charts.
global:
  # -- (object) redis.password will be used to set `TENZU_EVENTS__REDIS_PASSWORD` if defined
  # You still need to define redis.host as a local value.
  # Useful if you're using bitnami/redis as this value will also be used
  redis:
  # -- (object) The expected global value for postgres is an object formatted like
  # {auth: {password: string, username: string, database: string}}
  #  in order to set respectively `TENZU_DB__PASSWORD`, `TENZU_DB__USER` and `TENZU_DB__NAME`.
  # You still need to define postgres.host as a local value.
  # Useful if you're using bitnami/postgresql as this value will also be used
  postgresql:
  # -- (string) host for the backend, domain only without protocol,
  # Will be used to set `TENZU_BACKEND_URL`
  # If exposed via ingress, it should be the same as the ingress domain
  backendDomain:
  # -- (string) host for the backend, domain only without protocol,
  # Will be used to set `TENZU_FRONTEND_URL`
  # If exposed via ingress, it should be the same as the ingress domain
  frontendDomain:
