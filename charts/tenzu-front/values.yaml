# Default values for tenzu-front.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# -- number of pod replicas for the api backend and the worker service if not using autoscaling
# see: https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/
replicaCount: 1

sentry:
  # -- Whether to set the environment variable expected by the error tracker
  enabled: False
  # -- (string) Used to populate json config `sentry.dsn`
  dsn:
  # -- (string) Used to populate json config `sentry.environment`,
  # sentry.release will be set using the image.tag value when docker image is built
  environment:

# -- Image to use for the application
# see: https://kubernetes.io/docs/concepts/containers/images/
image:
  repository: ghcr.io/biru-scop/tenzu-back
  pullPolicy: IfNotPresent
  # -- Overrides the image tag
  # @default -- Uses the .Chart.AppVersion if not set
  tag: latest

# -- (list) List of secrets needed to pull an image from a private repository
# see: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets:

# -- Used by name template: to fill the app.kubernetes.io/name label
# @default -- will use .Chart.Name
nameOverride: ""
# -- Used by fullname template: to fill the name of all created kubernetes component
# @default -- will use .Release.Name suffixed with name template, if .Release.Name does not already contains it
fullnameOverride: ""

# -- service account properties
serviceAccount:
  # -- Specifies whether a service account should be created
  create: true
  # -- Automatically mount a ServiceAccount's API credentials
  automount: true
  # -- Annotations to add to the service account
  annotations: {}
  # -- The name of the service account to use.
  # @default -- If create is true, a name is generated using the fullname template, else it will be set to "default"
  name: ""

# -- Extra annotation to put on backend and task queue Deployment objects
# see: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# -- Extra labels to put on backend and task queue Deployment objects
# see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}
# -- definition of the pod level securityContext on backend and task queue Deployment objects
podSecurityContext: {}
# -- definition of the container level securityContext on backend and task queue Deployment objects
securityContext: {}

# -- see: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # -- service type defined for the frontend
  type: ClusterIP
  # -- service port to access the frontend
  port: 80

# -- properties used to define an Ingress
# see: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  # -- will be used to set ingressClassName and "kubernetes.io/ingress.class" annotation depending on k8s version
  className: ""
  # -- ingress annotations, can be "kubernetes.io/ingress.class", "kubernetes.io/tls-acme", "cert-manager.io/cluster-issuer", etc.
  # @default -- Will set kubernetes.io/ingress.class to ingress.className if needed
  annotations: {}
  # -- list of the hosts that will be exposed
  hosts: []
  # -- Expect values in format {secretName: "", hosts: []},
  # If one of the domain in `ingress.hosts` is also defined as `global.backendUrl.host`
  # You must take care to define tls for it if you also set `global.backendUrl.scheme` to "https"
  tls: []

# -- container's resources definition set on every jobs and on the backend and task queue Deployment objects,
# If you want to set it, use the following format: `{limits: {cpu: 100m, memory: 128Mi}, requests: cpu: 100m, memory: 128Mi}}`
resources: {}


# -- livenessProbe for the container of the backend service
# see: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  httpGet:
    path: /
    port: http
# -- readinessProbe for the container of the backend service
# see: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
readinessProbe:
  httpGet:
    path: /
    port: http
# -- Whether to define a HorizontalPodAutoscaler with the following scaling properties on cpu and memory consumption
# see: https://kubernetes.io/docs/concepts/workloads/autoscaling/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# -- nodeSelector pod property for the backend and task queue Deployment objects
nodeSelector: {}
# -- tolerations pod property for the backend and task queue Deployment objects
tolerations: []
# -- affinity pod property for the backend and task queue Deployment objects
affinity: {}

# TODO fix all values related to volumes and document explicit usage
# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false
# Additional volumeMounts on the output Deployment definition.
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

# -- global values to share properties among charts.
global:
  # -- url used to serve the backend, will be used to set json config `api.baseDomain`, `api.scheme` and `wsUrl`
  backendUrl:
    scheme: 'https'
    websocketScheme: 'wss'
    # -- (string)
    host:
